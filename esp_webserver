#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <lwip/etharp.h>
#include <ESP8266HTTPClient.h>

extern "C" {
  #include "user_interface.h"
}

// ==================== CONFIGURATION ====================
#define SSID "Tunisie_Telecom-2.4G-2057"
#define PASS "W9793bb32b"
#define MAX_DEVICES 20
#define PC_IP "192.168.1.249"
#define PC_PORT 5000

// ==================== SERVEUR WEB ====================
ESP8266WebServer server(80);

// ==================== STRUCTURE DEVICE ====================
struct Device {
  uint8_t ip;
  uint8_t mac[6];
  uint8_t port;
  char type;
  bool fromARP;
  uint16_t openPorts[10];
  uint8_t openPortCount;
  unsigned long lastSeen;
  uint16_t scanAttempts;
};

Device devices[MAX_DEVICES];
uint8_t deviceCount = 0;
bool scanning = false;
unsigned long scanStartTime = 0;

// Variables pour le sniffer DDoS
unsigned long packetCount[256] = {0};  // Compteur par dernier octet MAC
bool isSniffing = false;            // Ã‰tat du sniffer (actif/inactif)
unsigned long snifferStartTime = 0; // Timestamp de dÃ©but de capture
unsigned long totalPacketsCaptured = 0; // Total de paquets capturÃ©s

// Structure paquet WiFi
typedef struct {
  signed rssi:8;
  unsigned rate:4;
  unsigned is_group:1;
  unsigned sig_mode:2;
  unsigned legacy_length:12;
  unsigned damatch0:1;
  unsigned damatch1:1;
  unsigned bssidmatch0:1;
  unsigned bssidmatch1:1;
  unsigned MCS:7;
  unsigned CWB:1;
  unsigned HT_length:16;
  unsigned Smoothing:1;
  unsigned Not_Sounding:1;
  unsigned Aggregation:1;
  unsigned STBC:2;
  unsigned FEC_CODING:1;
  unsigned SGI:1;
  unsigned rxend_state:8;
  unsigned ampdu_cnt:8;
  unsigned channel:4;
} RxControl;

typedef struct {
  RxControl rx_ctrl;
  uint8_t buf[36];
  uint16_t cnt;
  uint8_t packet[0];
} SnifferPacket;

// ==================== CALLBACK SNIFFER ====================
void ICACHE_RAM_ATTR packetSnifferCallback(uint8_t *buffer, uint16_t length) {
  // âš ï¸ ICACHE_RAM_ATTR = Fonction stockÃ©e en RAM (plus rapide)
  // NÃ©cessaire car appelÃ©e trÃ¨s frÃ©quemment (plusieurs milliers/sec)
  if (!isSniffing) return; // Si sniffer dÃ©sactivÃ©, ne rien faire
  
  SnifferPacket *snifferPacket = (SnifferPacket*) buffer; // Convertir le buffer brut en structure SnifferPacket
  uint8_t *packet = snifferPacket->packet;
  
  if (length < 24) return;  // Paquet trop court , ignorer
  
    // ========== ANALYSE DU FRAME CONTROL ==========
  // Les 2 premiers bytes du paquet = Frame Control
  uint16_t frameControl = ((uint16_t)packet[1] << 8) + packet[0];
  uint8_t frameType = (frameControl & 0x0C) >> 2; // Extraire le type de paquet (bits 2-3 du Frame Control)
    //                   0x0C = 0000 1100 en binaire
  //                   Masque pour isoler les bits 2-3
  //                   >> 2 = DÃ©calage de 2 bits vers la droite

    /*
  Types de paquets WiFi:
  - 0 = Management (beacon, probe, auth, deauth)
  - 1 = Control (RTS, CTS, ACK)
  - 2 = Data (donnÃ©es rÃ©elles) â† CE QUI NOUS INTÃ‰RESSE
  - 3 = Extension
  */
  totalPacketsCaptured++; // IncrÃ©menter le total
  
  // Compter par adresse MAC source
  if (frameType == 2 && length >= 16) {  // Paquet DATA
  // Si paquet DATA
    // Structure d'un paquet WiFi DATA:
    // [0-1]   Frame Control
    // [2-3]   Duration
    // [4-9]   Address 1 (Destination)
    // [10-15] Address 2 (Source) â† CE QUI NOUS INTÃ‰RESSE
    // [16-21] Address 3 (BSSID)
    // [22-23] Sequence Control
    // [24+]   DonnÃ©es
    uint8_t srcMAC[6]; // Buffer pour stocker la MAC source

    memcpy(srcMAC, &packet[10], 6); // Copier 6 bytes Ã  partir de packet[10]
    uint8_t index = srcMAC[5];  // Dernier octet MAC // Utiliser le dernier octet comme index
    packetCount[index]++;
  }
}

// ==================== PING ARP ====================
void arpPing(IPAddress ip) {
  ip4_addr_t ipaddr;
  IP4_ADDR(&ipaddr, ip[0], ip[1], ip[2], ip[3]);
  
  struct netif *netif = netif_default;
  if (netif != NULL) {
    etharp_request(netif, &ipaddr);
  }
}

// ==================== LIRE TABLE ARP ====================
bool getARPEntry(IPAddress ip, uint8_t* mac) {
  ip4_addr_t ipaddr;
  IP4_ADDR(&ipaddr, ip[0], ip[1], ip[2], ip[3]);
  
  struct eth_addr* ethAddr = NULL;
  ip4_addr_t* ipRet = NULL;
  struct netif* netif = NULL;
  
  for (int i = 0; i < ARP_TABLE_SIZE; i++) {
    if (etharp_get_entry(i, &ipRet, &netif, &ethAddr) != 0) {
      if (ipRet != NULL && ipRet->addr == ipaddr.addr) {
        if (ethAddr != NULL) {
          memcpy(mac, ethAddr->addr, 6);
          return true;
        }
      }
    }
  }
  return false;
}

// ==================== SCAN PORTS ====================
void scanPortsExtended(IPAddress ip, Device &device) {
  WiFiClient client;
  client.setTimeout(50);
  
  device.openPortCount = 0;
  device.scanAttempts = 0;
  
  uint16_t portsToScan[] = {
    21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 
    3306, 3389, 5000, 5432, 8080, 8888
  };
  
  for (uint8_t i = 0; i < 16 && device.openPortCount < 10; i++) {
    uint16_t port = portsToScan[i];
    device.scanAttempts++;
    
    if (client.connect(ip, port)) {
      device.openPorts[device.openPortCount] = port;
      device.openPortCount++;
      client.stop();
      delay(5);
    }
    
    yield();
  }
}

// ==================== DÃ‰TECTER TYPE ====================
char detectDeviceType(IPAddress ip, uint8_t* mac, uint8_t &port) {
  WiFiClient client;
  client.setTimeout(50);
  
  if (client.connect(ip, 80)) { client.stop(); port = 80; return 'W'; }
  if (client.connect(ip, 443)) { client.stop(); port = 443; return 'H'; }
  if (client.connect(ip, 8080)) { client.stop(); port = 8080; return 'W'; }
  if (client.connect(ip, 445)) { client.stop(); port = 445; return 'S'; }
  if (client.connect(ip, 22)) { client.stop(); port = 22; return 'L'; }
  if (client.connect(ip, 3389)) { client.stop(); port = 3389; return 'R'; }
  
  port = 0;
  return 'U';
}

// ==================== SCAN RÃ‰SEAU ====================
void performScan() {
  if (scanning) return;
  
  scanning = true;
  deviceCount = 0;
  scanStartTime = millis();
 
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘  SCAN RÃ‰SEAU AVANCÃ‰               â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  
  IPAddress localIP = WiFi.localIP();
  IPAddress gateway = WiFi.gatewayIP();
  uint8_t base[3] = {localIP[0], localIP[1], localIP[2]};
  
  Serial.printf("ğŸ“ RÃ©seau: %d.%d.%d.0/24\n", base[0], base[1], base[2]);
  Serial.printf("ğŸ“¡ ESP IP: %s\n", localIP.toString().c_str());
  
  Serial.println("\nPhase 1/4: Ping ARP...");
  
  for (uint8_t i = 1; i <= 254; i++) {
    if (i == localIP[3]) continue;
    
    IPAddress target(base[0], base[1], base[2], i);
    arpPing(target);
    
    if (i % 50 == 0) {
      Serial.printf("â³ ARP: %d/254\n", i);
      server.handleClient();
      yield();
    }
    
    if (i % 10 == 0) delay(10);
  }
  
  Serial.println("\nPhase 2/4: Lecture ARP...");
  delay(1000);
  
  for (uint8_t i = 1; i <= 254 && deviceCount < MAX_DEVICES; i++) {
    if (i == localIP[3]) continue;
    
    IPAddress target(base[0], base[1], base[2], i);
    uint8_t mac[6] = {0};
    
    if (getARPEntry(target, mac)) {
      uint8_t port;
      char type = detectDeviceType(target, mac, port);
      
      devices[deviceCount].ip = i;
      memcpy(devices[deviceCount].mac, mac, 6);
      devices[deviceCount].port = port;
      devices[deviceCount].type = type;
      devices[deviceCount].fromARP = true;
      devices[deviceCount].lastSeen = millis();
      devices[deviceCount].openPortCount = 0;
      devices[deviceCount].scanAttempts = 0;
      
      Serial.printf("âœ… %d.%d.%d.%d [%02X:%02X:%02X:%02X:%02X:%02X]\n",
                    base[0], base[1], base[2], i,
                    mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
      
      deviceCount++;
    }
    
    if (i % 50 == 0) {
      Serial.printf("â³ Scan: %d/254 | TrouvÃ©s: %d\n", i, deviceCount);
      yield();
    }
  }
  
  Serial.println("\nPhase 3/4: Scan ports...");
  
  for (uint8_t i = 0; i < deviceCount; i++) {
    IPAddress target(base[0], base[1], base[2], devices[i].ip);
    
    Serial.printf("ğŸ” Ports: %d.%d.%d.%d...", base[0], base[1], base[2], devices[i].ip);
    
    scanPortsExtended(target, devices[i]);
    
    Serial.printf(" %d ouverts\n", devices[i].openPortCount);
    
    if (i % 5 == 0) {
      yield();
      server.handleClient();
    }
  }
  
  unsigned long scanDuration = millis() - scanStartTime;
  Serial.printf("\nâœ… Scan ARP terminÃ©: %d appareils en %lu ms\n", deviceCount, scanDuration);
  
  scanning = false;
}

// âœ¨ NOUVEAU : Sniffer DDoS
void performDDoSDetection() {
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘  DÃ‰TECTION DDoS - MODE SNIFFER   â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  
  // RÃ©initialiser
  memset(packetCount, 0, sizeof(packetCount));
  totalPacketsCaptured = 0;
  
  Serial.println("âš ï¸  WiFi va se dÃ©connecter temporairement...");
  delay(1000);
  
  // Activer mode promiscuous
    /*
  Mode Promiscuous:
  - Normalement: ESP ne reÃ§oit que les paquets qui lui sont destinÃ©s
  - En promiscuous: ESP reÃ§oit TOUS les paquets WiFi du canal
  - Permet d'Ã©couter le trafic des autres appareils
  - UtilisÃ© par Wireshark, Aircrack-ng, etc.
  */
  wifi_set_opmode(STATION_MODE);
  wifi_promiscuous_enable(0);
  wifi_set_promiscuous_rx_cb(packetSnifferCallback);
  wifi_promiscuous_enable(1);
  
  isSniffing = true;
  snifferStartTime = millis();
  
  Serial.println("ğŸ” Capture active (20 secondes)...");
  
  // Capturer pendant 20 secondes
  while (millis() - snifferStartTime < 20000) {
    delay(100);
    
    if ((millis() - snifferStartTime) % 5000 < 150) {
      Serial.printf("ğŸ“Š Paquets: %lu\n", totalPacketsCaptured);
    }
  }
  
  isSniffing = false;
  wifi_promiscuous_enable(0);
  
  Serial.printf("\nâœ… Capture terminÃ©e: %lu paquets en 20s\n", totalPacketsCaptured);
  Serial.printf("ğŸ“ˆ DÃ©bit: %lu paquets/sec\n", totalPacketsCaptured / 20);
  
  // Reconnecter WiFi
  Serial.println("\nğŸ“¡ Reconnexion WiFi...");
  WiFi.mode(WIFI_STA);
  WiFi.begin(SSID, PASS);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nâœ… WiFi reconnectÃ©!");
  } else {
    Serial.println("\nâŒ Ã‰chec reconnexion");
  }
}

// ==================== BUILD JSON COMPLET ====================
String buildJSON() {
  String json = "{";
  json += "\"esp_ip\":\"" + WiFi.localIP().toString() + "\",";
  json += "\"scan_duration\":" + String(millis() - scanStartTime) + ",";
  json += "\"timestamp\":" + String(millis()) + ",";
  
  // âœ¨ NOUVEAU : DonnÃ©es DDoS
  json += "\"ddos_detection\":{";
  json += "\"total_packets\":" + String(totalPacketsCaptured) + ",";
  json += "\"packets_per_sec\":" + String(totalPacketsCaptured / 20) + ",";
  json += "\"capture_duration\":20000,";
  
  // Top sources
  json += "\"top_sources\":[";
  
  // Trouver top 10
  typedef struct {
    uint8_t index;
    unsigned long count;
  } Source;
  
  Source topSources[10] = {0};
  
  for (int i = 0; i < 256; i++) {
    if (packetCount[i] > 0) {
      for (int j = 0; j < 10; j++) {
        if (packetCount[i] > topSources[j].count) {
          for (int k = 9; k > j; k--) {
            topSources[k] = topSources[k-1];
          }
          topSources[j].index = i;
          topSources[j].count = packetCount[i];
          break;
        }
      }
    }
  }
  
  for (int i = 0; i < 10 && topSources[i].count > 0; i++) {
    if (i > 0) json += ",";
    json += "{\"mac_suffix\":" + String(topSources[i].index) + ",";
    json += "\"packet_count\":" + String(topSources[i].count) + "}";
  }
  
  json += "]},";  // Fin ddos_detection
  
  // Appareils (comme avant)
  json += "\"devices\":[";
  
  for (uint8_t i = 0; i < deviceCount; i++) {
    if (i > 0) json += ",";
    
    json += "{\"ip\":\"";
    json += String(WiFi.localIP()[0]) + "." + 
            String(WiFi.localIP()[1]) + "." + 
            String(WiFi.localIP()[2]) + "." + 
            String(devices[i].ip);
    json += "\",\"mac\":\"";
    
    for (int j = 0; j < 6; j++) {
      if (devices[i].mac[j] < 16) json += "0";
      json += String(devices[i].mac[j], HEX);
      if (j < 5) json += ":";
    }
    
    json += "\",\"type\":\"" + String(devices[i].type) + "\",";
    json += "\"primary_port\":" + String(devices[i].port) + ",";
    
    json += "\"open_ports\":[";
    for (uint8_t j = 0; j < devices[i].openPortCount; j++) {
      if (j > 0) json += ",";
      json += String(devices[i].openPorts[j]);
    }
    json += "],";
    
    json += "\"open_port_count\":" + String(devices[i].openPortCount) + ",";
    json += "\"scan_attempts\":" + String(devices[i].scanAttempts) + ",";
    json += "\"last_seen\":" + String(devices[i].lastSeen);
    json += "}";
  }
  
  json += "]}";
  
  return json;
}

// ==================== ENVOI PC ====================
void sendScanToPC(String json) {
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘   ENVOI DONNÃ‰ES VERS PC          â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("âŒ WiFi non connectÃ©!");
    return;
  }
  
  String url = "http://" + String(PC_IP) + ":" + String(PC_PORT) + "/scan";
  Serial.printf("ğŸ¯ URL: %s\n", url.c_str());
  Serial.printf("ğŸ“Š Appareils: %d\n", deviceCount);
  Serial.printf("ğŸ”¥ Paquets capturÃ©s: %lu\n", totalPacketsCaptured);
  
  HTTPClient http;
  WiFiClient client;
  
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(15000);
  
  Serial.println("ğŸ“¤ Envoi POST...");
  int httpCode = http.POST(json);
  
  Serial.printf("ğŸ“¨ Code HTTP: %d\n", httpCode);
  
  if (httpCode > 0) {
    Serial.printf("âœ… SuccÃ¨s! Code: %d\n", httpCode);
    
    if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_CREATED) {
      String response = http.getString();
      Serial.println("ğŸ“¥ RÃ©ponse: " + response);
    }
  } else {
    Serial.println("âŒ ERREUR!");
    Serial.printf("Code: %d - %s\n", httpCode, http.errorToString(httpCode).c_str());
  }
  
  http.end();
  Serial.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

// ==================== PAGE HTML THÃˆME ROUGE CYBERSEC ====================
String getHTML() {
  IPAddress ip = WiFi.localIP();
  IPAddress gateway = WiFi.gatewayIP();
  
  String html = "<!DOCTYPE html><html><head><meta charset='UTF-8'>"
  "<meta name='viewport' content='width=device-width,initial-scale=1'>"
  "<title>ğŸ›¡ï¸ ESP8266 Scanner</title><style>"
  
  // CSS avec thÃ¨me rouge cybersec
  "*{margin:0;padding:0;box-sizing:border-box}"
  
  "body{"
    "font-family:'Segoe UI','Inter',-apple-system,sans-serif;"
    "background:linear-gradient(135deg,#1a1a2e 0%,#16213e 25%,#0f3460 50%,#533483 100%);"
    "color:#fff;"
    "padding:20px;"
    "min-height:100vh;"
    "position:relative;"
    "overflow-x:hidden"
  "}"
  
  // Background avec effet rouge
  "body::before{"
    "content:'';"
    "position:fixed;"
    "top:0;left:0;"
    "width:100%;height:100%;"
    "background-image:"
      "radial-gradient(circle at 20% 30%,rgba(239,83,80,0.15) 0%,transparent 50%),"
      "radial-gradient(circle at 80% 70%,rgba(244,67,54,0.1) 0%,transparent 50%),"
      "radial-gradient(circle at 50% 50%,rgba(255,82,82,0.05) 0%,transparent 70%);"
    "pointer-events:none;"
    "z-index:0;"
    "animation:gradientShift 10s ease infinite"
  "}"
  
  "@keyframes gradientShift{"
    "0%,100%{opacity:0.8}"
    "50%{opacity:1}"
  "}"
  
  ".container{"
    "max-width:900px;"
    "margin:0 auto;"
    "position:relative;"
    "z-index:1"
  "}"
  
  // Header
  ".header{"
    "text-align:center;"
    "margin-bottom:25px;"
    "padding:25px;"
    "background:linear-gradient(135deg,rgba(239,83,80,0.15),rgba(244,67,54,0.1));"
    "border-radius:15px;"
    "backdrop-filter:blur(10px);"
    "box-shadow:0 8px 32px rgba(239,83,80,0.2);"
    "border:1px solid rgba(239,83,80,0.3)"
  "}"
  
  "h1{"
    "background:linear-gradient(135deg,#ef5350,#ff6f00,#ff1744);"
    "-webkit-background-clip:text;"
    "-webkit-text-fill-color:transparent;"
    "background-clip:text;"
    "font-size:2em;"
    "font-weight:700;"
    "margin-bottom:8px;"
    "filter:drop-shadow(0 0 20px rgba(239,83,80,0.5))"
  "}"
  
  ".subtitle{"
    "color:#ffab91;"
    "font-size:0.9em;"
    "font-weight:400"
  "}"
  
  // Stats grid
  ".stats-grid{"
    "display:grid;"
    "grid-template-columns:repeat(3,1fr);"
    "gap:15px;"
    "margin-bottom:25px"
  "}"
  
  ".stat-card{"
    "background:linear-gradient(135deg,rgba(30,30,50,0.9),rgba(20,20,40,0.9));"
    "padding:20px;"
    "border-radius:12px;"
    "border:1px solid rgba(239,83,80,0.3);"
    "backdrop-filter:blur(10px);"
    "text-align:center;"
    "transition:all 0.3s ease;"
    "box-shadow:0 4px 15px rgba(0,0,0,0.3)"
  "}"
  
  ".stat-card:hover{"
    "transform:translateY(-5px);"
    "border-color:rgba(239,83,80,0.6);"
    "box-shadow:0 8px 25px rgba(239,83,80,0.4)"
  "}"
  
  ".stat-icon{"
    "font-size:2.5em;"
    "margin-bottom:10px;"
    "filter:drop-shadow(0 0 10px currentColor)"
  "}"
  
  ".stat-number{"
    "font-size:2.5em;"
    "font-weight:700;"
    "margin:10px 0;"
    "color:#00e676;"
    "text-shadow:0 0 20px #00e676"
  "}"
  
  ".stat-label{"
    "color:#ffccbc;"
    "font-size:0.8em;"
    "text-transform:uppercase;"
    "letter-spacing:1px;"
    "font-weight:600"
  "}"
  
  // Info section
  ".info-section{"
    "background:linear-gradient(135deg,rgba(30,30,50,0.9),rgba(20,20,40,0.85));"
    "padding:20px;"
    "border-radius:15px;"
    "border:1px solid rgba(239,83,80,0.3);"
    "backdrop-filter:blur(10px);"
    "margin-bottom:20px;"
    "box-shadow:0 8px 32px rgba(0,0,0,0.4)"
  "}"
  
  ".info-item{"
    "display:flex;"
    "justify-content:space-between;"
    "padding:10px 0;"
    "border-bottom:1px solid rgba(255,255,255,0.1)"
  "}"
  
  ".info-item:last-child{border-bottom:none}"
  
  ".info-label{"
    "color:#ffccbc;"
    "font-weight:600"
  "}"
  
  ".info-value{"
    "color:#ff5252;"
    "font-weight:700;"
    "font-family:'Courier New',monospace"
  "}"
  
  // Button
  ".scan-btn{"
    "display:block;"
    "width:100%;"
    "padding:18px;"
    "background:linear-gradient(135deg,#ff1744,#f50057,#d500f9);"
    "color:white;"
    "border:none;"
    "border-radius:12px;"
    "font-size:1.2em;"
    "font-weight:700;"
    "cursor:pointer;"
    "box-shadow:0 6px 20px rgba(255,23,68,0.5);"
    "transition:all 0.3s ease;"
    "margin-bottom:20px;"
    "text-transform:uppercase;"
    "letter-spacing:1px"
  "}"
  
  ".scan-btn:hover{"
    "transform:translateY(-3px);"
    "box-shadow:0 10px 30px rgba(255,23,68,0.7)"
  "}"
  
  ".scan-btn:active{"
    "transform:translateY(-1px)"
  "}"
  
  ".scan-btn:disabled{"
    "opacity:0.5;"
    "cursor:not-allowed"
  "}"
  
  // Devices section
  ".devices-section{"
    "background:linear-gradient(135deg,rgba(30,30,50,0.9),rgba(20,20,40,0.85));"
    "padding:25px;"
    "border-radius:15px;"
    "border:1px solid rgba(239,83,80,0.3);"
    "backdrop-filter:blur(10px);"
    "box-shadow:0 8px 32px rgba(0,0,0,0.4)"
  "}"
  
  "h2{"
    "background:linear-gradient(135deg,#ef5350,#ff6f00);"
    "-webkit-background-clip:text;"
    "-webkit-text-fill-color:transparent;"
    "background-clip:text;"
    "margin-bottom:20px;"
    "border-bottom:2px solid rgba(239,83,80,0.4);"
    "padding-bottom:12px;"
    "font-size:1.5em;"
    "font-weight:600"
  "}"
  
  ".device{"
    "background:rgba(30,30,50,0.6);"
    "padding:15px;"
    "margin:12px 0;"
    "border-radius:10px;"
    "border-left:4px solid #ef5350;"
    "transition:all 0.3s ease"
  "}"
  
  ".device:hover{"
    "transform:translateX(5px);"
    "box-shadow:0 6px 20px rgba(239,83,80,0.3);"
    "border-color:#ff1744"
  "}"
  
  ".device-ip{"
    "color:#ff5252;"
    "font-weight:700;"
    "font-size:1.1em;"
    "margin-bottom:8px"
  "}"
  
  ".device-mac{"
    "color:#b0bec5;"
    "font-size:0.9em;"
    "font-family:'Courier New',monospace;"
    "margin:5px 0"
  "}"
  
  ".device-ports{"
    "color:#ffab91;"
    "font-size:0.85em;"
    "margin-top:5px"
  "}"
  
  ".empty-state{"
    "text-align:center;"
    "padding:40px 20px;"
    "color:#78909c"
  "}"
  
  ".empty-state h3{"
    "color:#00e676;"
    "font-size:1.3em;"
    "margin-bottom:8px;"
    "text-shadow:0 0 15px #00e676"
  "}"
  
  // Status badge
  ".status-online{"
    "display:inline-block;"
    "padding:5px 12px;"
    "background:linear-gradient(135deg,rgba(0,230,118,0.2),rgba(0,200,83,0.2));"
    "color:#00e676;"
    "border:2px solid #00e676;"
    "border-radius:20px;"
    "font-size:0.8em;"
    "font-weight:700;"
    "box-shadow:0 0 15px rgba(0,230,118,0.5);"
    "animation:pulse 2s infinite"
  "}"
  
  "@keyframes pulse{"
    "0%,100%{box-shadow:0 0 15px rgba(0,230,118,0.5)}"
    "50%{box-shadow:0 0 25px rgba(0,230,118,0.8)}"
  "}"
  
  // Responsive
  "@media(max-width:768px){"
    ".stats-grid{grid-template-columns:1fr}"
    "h1{font-size:1.5em}"
    ".stat-number{font-size:2em}"
  "}"
  
  "</style></head><body>"
  "<div class='container'>"
  
  // Header
  "<div class='header'>"
    "<h1>ğŸ›¡ï¸ ESP8266 Network Scanner</h1>"
    "<div class='subtitle'>DÃ©tection avancÃ©e + DDoS Sniffer</div>"
  "</div>"
  
  // Stats
  "<div class='stats-grid'>"
    "<div class='stat-card'>"
      "<div class='stat-icon'>ğŸ“±</div>"
      "<div class='stat-label'>Appareils</div>"
      "<div class='stat-number'>" + String(deviceCount) + "</div>"
    "</div>"
    "<div class='stat-card'>"
      "<div class='stat-icon'>ğŸ”¥</div>"
      "<div class='stat-label'>Paquets WiFi</div>"
      "<div class='stat-number' style='font-size:1.8em'>" + String(totalPacketsCaptured) + "</div>"
    "</div>"
    "<div class='stat-card'>"
      "<div class='stat-icon'>âœ…</div>"
      "<div class='stat-label'>Status</div>"
      "<div style='margin-top:10px'><span class='status-online'>EN LIGNE</span></div>"
    "</div>"
  "</div>"
  
  // Info section
  "<div class='info-section'>"
    "<div class='info-item'>"
      "<span class='info-label'>ğŸ“¡ WiFi</span>"
      "<span class='info-value'>" + String(SSID) + "</span>"
    "</div>"
    "<div class='info-item'>"
      "<span class='info-label'>ğŸŒ IP ESP</span>"
      "<span class='info-value'>" + ip.toString() + "</span>"
    "</div>"
    "<div class='info-item'>"
      "<span class='info-label'>ğŸ”€ Gateway</span>"
      "<span class='info-value'>" + gateway.toString() + "</span>"
    "</div>"
    "<div class='info-item'>"
      "<span class='info-label'>ğŸ–¥ï¸ Serveur PC</span>"
      "<span class='info-value'>" + String(PC_IP) + ":" + String(PC_PORT) + "</span>"
    "</div>"
    "<div class='info-item'>"
      "<span class='info-label'>ğŸ“¶ Signal</span>"
      "<span class='info-value'>" + String(WiFi.RSSI()) + " dBm</span>"
    "</div>"
    "<div class='info-item'>"
      "<span class='info-label'>ğŸ”¥ DÃ©bit Sniffer</span>"
      "<span class='info-value'>" + String(totalPacketsCaptured / 20) + " pkt/s</span>"
    "</div>"
  "</div>"
  
  // Scan button
  "<button class='scan-btn' onclick='scan()' id='scanBtn'>ğŸ” DÃ©marrer le scan rÃ©seau</button>"
  
  // Devices section
  "<div class='devices-section'>"
    "<h2>ğŸ“± Appareils DÃ©tectÃ©s (" + String(deviceCount) + ")</h2>";
  
  if (deviceCount == 0) {
    html += "<div class='empty-state'>"
      "<h3>âœ… Aucun scan effectuÃ©</h3>"
      "<p>Lancez un scan pour dÃ©couvrir les appareils du rÃ©seau</p>"
    "</div>";
  } else {
    for (uint8_t i = 0; i < deviceCount; i++) {
      html += "<div class='device'>"
        "<div class='device-ip'>ğŸ”¹ " + String(ip[0]) + "." + String(ip[1]) + "." + 
                String(ip[2]) + "." + String(devices[i].ip) + "</div>"
        "<div class='device-mac'>ğŸ”– MAC: ";
      
      for (int j = 0; j < 6; j++) {
        if (devices[i].mac[j] < 16) html += "0";
        html += String(devices[i].mac[j], HEX);
        if (j < 5) html += ":";
      }
      
      html += "</div>";
      
      if (devices[i].openPortCount > 0) {
        html += "<div class='device-ports'>ğŸ”“ Ports ouverts: " + String(devices[i].openPortCount);
        html += " [";
        for (uint8_t j = 0; j < devices[i].openPortCount && j < 5; j++) {
          if (j > 0) html += ", ";
          html += String(devices[i].openPorts[j]);
        }
        if (devices[i].openPortCount > 5) html += "...";
        html += "]</div>";
      }
      
      html += "</div>";
    }
  }
  
  html += "</div>" // devices-section
  "</div>" // container
  
  // JavaScript
  "<script>"
  "function scan(){"
    "const btn=document.getElementById('scanBtn');"
    "btn.disabled=true;"
    "btn.textContent='â³ Scan en cours (40s)...';"
    "fetch('/scan')"
      ".then(()=>{"
        "setTimeout(()=>location.reload(),40000);" // Reload aprÃ¨s 40s (20s ARP + 20s sniffer)
      "})"
      ".catch(err=>{"
        "alert('Erreur: '+err);"
        "btn.disabled=false;"
        "btn.textContent='ğŸ” DÃ©marrer le scan rÃ©seau';"
      "});"
  "}"
  "</script>"
  
  "</body></html>";
  
  return html;
}

void handleRoot() { server.send(200, "text/html", getHTML()); }

void handleScan() {
  server.send(200, "text/plain", "Scan dÃ©marrÃ©");
  
  // Scan ARP
  performScan();
  
  // DÃ©tection DDoS
  performDDoSDetection();
  
  // Envoi
  if (WiFi.status() == WL_CONNECTED) {
    String json = buildJSON();
    sendScanToPC(json);
  }
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘  ESP8266 SCANNER v5.0         â•‘");
  Serial.println("â•‘  + DÃ©tection DDoS RÃ‰ELLE      â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  
  WiFi.mode(WIFI_STA);
  WiFi.begin(SSID, PASS);
  
  Serial.print("ğŸ“¡ Connexion");
  
  uint8_t tries = 0;
  while (WiFi.status() != WL_CONNECTED && tries < 30) {
    delay(500);
    Serial.print(".");
    tries++;
  }
  
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("âœ… ConnectÃ©!");
    Serial.printf("ğŸ“ IP ESP: %s\n", WiFi.localIP().toString().c_str());
    Serial.printf("ğŸ–¥ï¸ IP PC: %s:%d\n", PC_IP, PC_PORT);
    
    server.on("/", handleRoot);
    server.on("/scan", handleScan);
    server.begin();
    
    Serial.println("ğŸŒ Serveur actif\n");
    
    delay(2000);
    
    // Premier scan complet
    performScan();
    performDDoSDetection();
    
    if (WiFi.status() == WL_CONNECTED) {
      String json = buildJSON();
      sendScanToPC(json);
    }
  } else {
    Serial.println("âŒ Ã‰chec WiFi!");
  }
}

// ==================== LOOP ====================
void loop() {
  server.handleClient();
  yield();

  static unsigned long lastScan = 0;
  const unsigned long scanInterval = 60000; // 60 secondes

  if (!scanning && !isSniffing && millis() - lastScan > scanInterval) {
    lastScan = millis();
    
    Serial.println("\nğŸ” Scan automatique...");
    
    // Scan ARP
    performScan();
    
    // DÃ©tection DDoS
    performDDoSDetection();
    
    // Envoi
    if (WiFi.status() == WL_CONNECTED) {
      String json = buildJSON();
      sendScanToPC(json);
    }
  }
}
